<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BlueZero (BØ): BlueZero</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BlueZero (BØ)
   </div>
   <div id="projectbrief">Middleware for distributed applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">BlueZero </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>BlueZero (in short, B0) is an open-source library for developing distributed applications.</p>
<p>The building blocks of B0 are the <b>nodes</b>, which can talk to each other by sending <b>messages</b> over <b>sockets</b>. Multiple nodes can exist in the same thread, or in multiple threads, or in multiple processes, or distributed across multiple machines.</p>
<p>A message can be any sequence of bytes, and it is guaranteed to be delivered atomically.</p>
<p>A socket is an abstraction for connecting nodes to each other, and sending messages.</p>
<p>The two principal paradigms of communication are the <b>client-server</b>, and the <b>publish-subscribe</b>.</p>
<p>In the client-server pattern, a client node sends one request to a server node, addressed by name (i.e. the service name), and receives back one reply from the server node. The communication in this pattern is synchronous.</p>
<p>In the publish-subscribe pattern, a publisher node sends data to a channel addressed by name (i.e. the topic name), and any node which is interested in that data, can subscribe to that topic in order to receive it. The communication in this pattern is asynchronous.</p>
<h1><a class="anchor" id="nodes"></a>
Nodes</h1>
<p>The main entity in the BlueZero is the node. A node can represent a process running in a machine. Anyway, there is no such restriction as one-node-per-process, or one-node-per-thread, so it is possible to have many nodes running in the same process. See also <a class="el" href="index.html#threading">Threading and thread safety</a>.</p>
<p>The main class used to create a node is <a class="el" href="classb0_1_1_node.html" title="The abstraction for a node in the network. ">b0::Node</a>. Node uses two-phase initialization, so you must call <a class="el" href="classb0_1_1_node.html#a22299ab013b471c19f5935e3a0bede2b" title="Initialize the node (connect to resolve, start heartbeat, announce node name) ">b0::Node::init()</a> after the constructor, and <a class="el" href="classb0_1_1_node.html#a8b0fc9e81f907e0542657d7b591baa61" title="Node cleanup: stop all threads, send a shutdown notification to resolver, and so on... ">b0::Node::cleanup()</a> before the destructor. <b>Do not call <a class="el" href="classb0_1_1_node.html#a22299ab013b471c19f5935e3a0bede2b" title="Initialize the node (connect to resolve, start heartbeat, announce node name) ">b0::Node::init()</a> from your node class constructor!</b></p>
<p>The methods of <a class="el" href="classb0_1_1_node.html" title="The abstraction for a node in the network. ">b0::Node</a> class communicate with the resolver node (see below) to perform some handshaking and naming assignment and resolution.</p>
<p><a class="el" href="classb0_1_1_node.html#a12710a77532db0989c1def92c68e74f5" title="Read all available messages from the various ZeroMQ sockets, and dispatch them to callbacks...">b0::Node::spinOnce()</a> must be called periodically to process incoming messages (the method <a class="el" href="classb0_1_1_node.html#a5d9487adcd1faaad6c460b545bb7bd11" title="Run the spin loop. ">b0::Node::spin()</a> does exactly this, until node shutdown is requested).</p>
<div class="image">
<img src="node-state-machine.png" alt="node-state-machine.png"/>
<div class="caption">
Node state transtion diagram.</div></div>
<p><a class="el" href="classb0_1_1_node.html#a22299ab013b471c19f5935e3a0bede2b" title="Initialize the node (connect to resolve, start heartbeat, announce node name) ">b0::Node::init()</a> will initialize the node and announce its name to the resolver node, and it will initialize each of its publishers, subscribers, clients and servers.</p>
<p>Any publishers, subscribers, service client and servers must be constructed prior to calling <a class="el" href="classb0_1_1_node.html#a22299ab013b471c19f5935e3a0bede2b" title="Initialize the node (connect to resolve, start heartbeat, announce node name) ">b0::Node::init()</a>, although there is a way to dynamically create such sockets afterwards (by setting the <code>managed</code> flag to false).</p>
<h1><a class="anchor" id="topics"></a>
Topics</h1>
<p>When using topics, messages are routed via a transport system using publish / subscribe semantics. The topic is a name used to identify the content of the messages. A node that is interested in a certain kind of data will subscribe to the appropriate topic. There may be multiple concurrent publishers and subscribers for a single topic. and a single node may publish and/or subscribe to multiple topics. In general, publishers and subscribers are not aware of each others' existence. The idea is to decouple the production of information from its consumption. Logically, one can think of a topic as a strongly typed message bus. Each bus has a name, and anyone can connect to the bus to send or receive messages as long as they are the right type.</p>
<p>Note: topic names can be changed at runtime; see <a class="el" href="remapping.html">Remapping: dynamically changing names of nodes and sockets</a>.</p>
<h1><a class="anchor" id="services"></a>
Services</h1>
<p>The publish / subscribe model is a very flexible communication paradigm, but its many-to-many, one-way transport is not appropriate for request / reply interactions, which are often required in a distributed system. Request / reply is done via services, which are defined by a pair of message structures: one for the request and one for the reply. A providing node offers a service under a name and a client uses the service by sending the request message and awaiting the reply.</p>
<p>Note: service names can be changed at runtime; see <a class="el" href="remapping.html">Remapping: dynamically changing names of nodes and sockets</a>.</p>
<h1><a class="anchor" id="threading"></a>
Threading and thread safety</h1>
<p>The functions of the library are generally not thread-safe (unless stated otherwise).</p>
<p>Thus, every node's non-thread-safe methods must be accessed always from the same thread which created the node.</p>
<h1><a class="anchor" id="resolver_intro"></a>
Resolver</h1>
<p>The most important part of the network is the resolver node.</p>
<p>The resolver node implements a part of the <a class="el" href="protocol.html">protocol</a>, with the other counterpart of the protocol implemented by the <a class="el" href="classb0_1_1_node.html">node</a>.</p>
<p>The resolver node is implemented in <a class="el" href="classb0_1_1resolver_1_1_resolver.html" title="The resolver node. ">b0::resolver::Resolver</a> and will provide following services to other nodes:</p>
<ul>
<li>node name resolution</li>
<li>socket name resolution (for service client / server sockets)</li>
<li>messages routing (for publisher / subscriber sockets)</li>
<li>liveness monitoring</li>
<li>tracking of connected nodes</li>
<li>topics / services introspection (see <a class="el" href="graph.html">Graph protocol</a>)</li>
<li>clock synchronization (see <a class="el" href="timesync.html">Time Synchronization</a>)</li>
</ul>
<p><b>Important:</b> you must have the resolver node running prior to running any node. See <a class="el" href="remote_nodes.html">Connecting remote nodes</a> for more information about running distributed nodes.</p>
<p>See also <a class="el" href="remote_nodes.html">Connecting remote nodes</a> for information about connecting remote nodes.</p>
<h1><a class="anchor" id="examples"></a>
Examples</h1>
<h2><a class="anchor" id="example_pubsub"></a>
Topics (Publisher/Subscriber)</h2>
<p>Example of how to create a simple node with one publisher and sending some messages to some topic:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;b0/node.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;b0/publisher.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * This callback will be called continuously by the b0::Node::spin() method</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> callback(<a class="code" href="classb0_1_1_publisher.html">b0::Publisher</a> &amp;pub)</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> i = 0;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a message to send</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    std::string msg = (boost::format(<span class="stringliteral">&quot;msg-%d&quot;</span>) % i++).str();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Send the message on the &quot;A&quot; topic</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Sending: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</div><div class="line">    pub.<a class="code" href="classb0_1_1_publisher.html#a2d2b36fe0dfcce9d42b42c15a7e55120">publish</a>(msg);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Initialize B0</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="b0_8h.html#ac55b543fb777f0709e3a135a3f47d852">b0::init</a>(argc, argv);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a node named &quot;publisher&quot;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_node.html">b0::Node</a> node(<span class="stringliteral">&quot;publisher&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a Publisher to publish on topic &quot;A&quot;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_publisher.html">b0::Publisher</a> pub(&amp;node, <span class="stringliteral">&quot;A&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Initialize the node (will announce node name to the network, and do other nice things)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.init();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Spin the node (continuously process messages, and call callback() to send a message)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.spin([&amp;]() { callback(pub); });</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Perform cleanup (stop threads, notify resolver that this node has quit, ...)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.cleanup();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --><p>And the corresponding example of a simple node with one subscriber:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;b0/node.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;b0/subscriber.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * This callback will be called whenever a message is received on any</span></div><div class="line"><span class="comment"> * of the subscribed topics</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> callback(<span class="keyword">const</span> std::string &amp;msg)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Received: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Initialize B0</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="b0_8h.html#ac55b543fb777f0709e3a135a3f47d852">b0::init</a>(argc, argv);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a node named &quot;subscriber&quot;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_node.html">b0::Node</a> node(<span class="stringliteral">&quot;subscriber&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a Subscriber to subscribe to topic &quot;A&quot;</span></div><div class="line"><span class="comment">     * It will call the specified callback upon receiving messages</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_subscriber.html">b0::Subscriber</a> sub(&amp;node, <span class="stringliteral">&quot;A&quot;</span>, &amp;callback);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Initialize the node (will announce node name to the network, and do other nice things)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.init();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Spin the node (continuously process incoming messages and call callbacks)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.spin();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Perform cleanup (stop threads, notify resolver that this node has quit, ...)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.cleanup();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --><p>You can have multiple publishers and subscribers as well:</p>
<p><a class="el" href="publisher_subscriber_multi_2multi_publisher_8cpp-example.html">Node with multiple publishers</a></p>
<p><a class="el" href="publisher_subscriber_multi_2multi_subscriber_8cpp-example.html">Node with multiple subscribers</a></p>
<p>And following is an example of using it in a more object-oriented way:</p>
<p><a class="el" href="publisher_subscriber_oop_2publisher_node_object_8cpp-example.html">OOP publisher node</a></p>
<p><a class="el" href="publisher_subscriber_oop_2subscriber_node_object_8cpp-example.html">OOP subscriber node</a></p>
<h2><a class="anchor" id="example_clisrv"></a>
Services (Client/Server)</h2>
<p>Example of how to create a simple node with a service client:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;b0/node.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;b0/service_client.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Initialize B0</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="b0_8h.html#ac55b543fb777f0709e3a135a3f47d852">b0::init</a>(argc, argv);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a node named &quot;client&quot;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_node.html">b0::Node</a> node(<span class="stringliteral">&quot;client&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a ServiceClient that will connect to the service &quot;control&quot;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_service_client.html">b0::ServiceClient</a> cli(&amp;node, <span class="stringliteral">&quot;control&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Initialize the node (will announce the node name to the network, and do other nice things)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.init();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a request message</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    std::string req = <span class="stringliteral">&quot;hello&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Sending: &quot;</span> &lt;&lt; req &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * The response will be written here</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    std::string rep;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Call the service (blocking)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    cli.call(req, rep);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Received: &quot;</span> &lt;&lt; rep &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Perform cleanup (stop threads, notify resolver that this node has quit, ...)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.cleanup();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --><p>And the corresponding example of a simple node with a service server:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;b0/node.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;b0/service_server.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * This callback will be called whenever a request message is read from the socket</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> callback(<span class="keyword">const</span> std::string &amp;req, std::string &amp;rep)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Received: &quot;</span> &lt;&lt; req &lt;&lt; std::endl;</div><div class="line">    rep = <span class="stringliteral">&quot;hi&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Sending: &quot;</span> &lt;&lt; rep &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Initialize B0</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="b0_8h.html#ac55b543fb777f0709e3a135a3f47d852">b0::init</a>(argc, argv);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a node named &quot;server&quot;</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Note: if another node with the same name exists on the network, this node will</span></div><div class="line"><span class="comment">     *       get a different name</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_node.html">b0::Node</a> node(<span class="stringliteral">&quot;server&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a ServiceServer for a service named &quot;control&quot;</span></div><div class="line"><span class="comment">     * It will call the specified callback upon receiving requests.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_service_server.html">b0::ServiceServer</a> srv(&amp;node, <span class="stringliteral">&quot;control&quot;</span>, &amp;callback);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Initialize the node (will announce node name to the network, and do other nice things)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.init();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Spin the node (continuously process incoming requests and call callbacks)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.spin();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Perform cleanup (stop threads, notify resolver that this node has quit, ...)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.cleanup();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --><p>And the same thing, object-oriented:</p>
<p><a class="el" href="client_server_oop_2client_node_object_8cpp-example.html">OOP client node</a></p>
<p><a class="el" href="client_server_oop_2server_node_object_8cpp-example.html">OOP server node</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
